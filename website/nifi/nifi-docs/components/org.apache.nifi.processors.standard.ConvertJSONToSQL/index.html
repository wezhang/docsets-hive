<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"></meta><title>ConvertJSONToSQL</title><link rel="stylesheet" href="../../css/component-usage.css" type="text/css"></link></head><body><h2>Description: </h2><p>Converts a JSON-formatted FlowFile into an UPDATE or INSERT SQL statement. The incoming FlowFile is expected to be "flat" JSON message, meaning that it consists of a single JSON element and each field maps to a simple type. If a field maps to a JSON object, that JSON object will be interpreted as Text. If the input is an array of JSON elements, each element in the array is output as a separate FlowFile to the 'sql' relationship. Upon successful conversion, the original FlowFile is routed to the 'original' relationship and the SQL is routed to the 'sql' relationship.</p><h3>Tags: </h3><p>json, sql, database, rdbms, insert, update, relational, flat</p><h3>Properties: </h3><p>In the list below, the names of required properties appear in <strong>bold</strong>. Any other properties (not in bold) are considered optional. The table also indicates any default values, and whether a property supports the <a href="../../html/expression-language-guide.html">NiFi Expression Language</a>.</p><table id="properties"><tr><th>Name</th><th>Default Value</th><th>Allowable Values</th><th>Description</th></tr><tr><td id="name"><strong>JDBC Connection Pool</strong></td><td id="default-value"></td><td id="allowable-values"><strong>Controller Service API: </strong><br/>DBCPService<br/><strong>Implementation:</strong><br/><a href="../org.apache.nifi.dbcp.DBCPConnectionPool/index.html">DBCPConnectionPool</a></td><td id="description">Specifies the JDBC Connection Pool to use in order to convert the JSON message to a SQL statement. The Connection Pool is necessary in order to determine the appropriate database column types.</td></tr><tr><td id="name"><strong>Statement Type</strong></td><td id="default-value"></td><td id="allowable-values"><ul><li>UPDATE</li><li>INSERT</li></ul></td><td id="description">Specifies the type of SQL Statement to generate</td></tr><tr><td id="name"><strong>Table Name</strong></td><td id="default-value"></td><td id="allowable-values"></td><td id="description">The name of the table that the statement should update<br/><strong>Supports Expression Language: true</strong></td></tr><tr><td id="name">Catalog Name</td><td id="default-value"></td><td id="allowable-values"></td><td id="description">The name of the catalog that the statement should update. This may not apply for the database that you are updating. In this case, leave the field empty<br/><strong>Supports Expression Language: true</strong></td></tr><tr><td id="name">Schema Name</td><td id="default-value"></td><td id="allowable-values"></td><td id="description">The name of the schema that the table belongs to. This may not apply for the database that you are updating. In this case, leave the field empty<br/><strong>Supports Expression Language: true</strong></td></tr><tr><td id="name">Translate Field Names</td><td id="default-value">true</td><td id="allowable-values"><ul><li>true</li><li>false</li></ul></td><td id="description">If true, the Processor will attempt to translate JSON field names into the appropriate column names for the table specified. If false, the JSON field names must match the column names exactly, or the column will not be updated</td></tr><tr><td id="name">Unmatched Field Behavior</td><td id="default-value">Ignore Unmatched Fields</td><td id="allowable-values"><ul><li>Ignore Unmatched Fields <img src="../../html/images/iconInfo.png" alt="Any field in the JSON document that cannot be mapped to a column in the database is ignored" title="Any field in the JSON document that cannot be mapped to a column in the database is ignored"></img></li><li>Fail <img src="../../html/images/iconInfo.png" alt="If the JSON document has any field that cannot be mapped to a column in the database, the FlowFile will be routed to the failure relationship" title="If the JSON document has any field that cannot be mapped to a column in the database, the FlowFile will be routed to the failure relationship"></img></li></ul></td><td id="description">If an incoming JSON element has a field that does not map to any of the database table's columns, this property specifies how to handle the situation</td></tr><tr><td id="name">Update Keys</td><td id="default-value"></td><td id="allowable-values"></td><td id="description">A comma-separated list of column names that uniquely identifies a row in the database for UPDATE statements. If the Statement Type is UPDATE and this property is not set, the table's Primary Keys are used. In this case, if no Primary Key exists, the conversion to SQL will fail. This property is ignored if the Statement Type is INSERT<br/><strong>Supports Expression Language: true</strong></td></tr></table><h3>Relationships: </h3><table id="relationships"><tr><th>Name</th><th>Description</th></tr><tr><td>sql</td><td>A FlowFile is routed to this relationship when its contents have successfully been converted into a SQL statement</td></tr><tr><td>original</td><td>When a FlowFile is converted to SQL, the original JSON FlowFile is routed to this relationship</td></tr><tr><td>failure</td><td>A FlowFile is routed to this relationship if it cannot be converted into a SQL statement. Common causes include invalid JSON content or the JSON content missing a required field (if using an INSERT statement type).</td></tr></table><h3>Reads Attributes: </h3>None specified.<h3>Writes Attributes: </h3><table id="writes-attributes"><tr><th>Name</th><th>Description</th></tr><tr><td>mime.type</td><td>Sets mime.type of FlowFile that is routed to 'sql' to 'text/plain'.</td></tr><tr><td>sql.table</td><td>Sets the sql.table attribute of FlowFile that is routed to 'sql' to the name of the table that is updated by the SQL statement.</td></tr><tr><td>sql.catalog</td><td>If the Catalog name is set for this database, specifies the name of the catalog that the SQL statement will update. If no catalog is used, this attribute will not be added.</td></tr><tr><td>fragment.identifier</td><td>All FlowFiles routed to the 'sql' relationship for the same incoming FlowFile (multiple will be output for the same incoming FlowFile if the incoming FlowFile is a JSON Array) will have the same value for the fragment.identifier attribute. This can then be used to correlate the results.</td></tr><tr><td>fragment.count</td><td>The number of SQL FlowFiles that were produced for same incoming FlowFile. This can be used in conjunction with the fragment.identifier attribute in order to know how many FlowFiles belonged to the same incoming FlowFile.</td></tr><tr><td>fragment.index</td><td>The position of this FlowFile in the list of outgoing FlowFiles that were all derived from the same incoming FlowFile. This can be used in conjunction with the fragment.identifier and fragment.count attributes to know which FlowFiles originated from the same incoming FlowFile and in what order the SQL FlowFiles were produced</td></tr><tr><td>sql.args.N.type</td><td>The output SQL statements are parameterized in order to avoid SQL Injection Attacks. The types of the Parameters to use are stored in attributes named sql.args.1.type, sql.args.2.type, sql.args.3.type, and so on. The type is a number representing a JDBC Type constant. Generally, this is useful only for software to read and interpret but is added so that a processor such as PutSQL can understand how to interpret the values.</td></tr><tr><td>sql.args.N.value</td><td>The output SQL statements are parameterized in order to avoid SQL Injection Attacks. The values of the Parameters to use are stored in the attributes named sql.args.1.value, sql.args.2.value, sql.args.3.value, and so on. Each of these attributes has a corresponding sql.args.N.type attribute that indicates how the value should be interpreted when inserting it into the database.</td></tr></table><h3>See Also:</h3><p><a href="../org.apache.nifi.processors.standard.PutSQL/index.html">PutSQL</a></p></body></html>