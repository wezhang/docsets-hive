<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"></meta><title>PutSQL</title><link rel="stylesheet" href="../../css/component-usage.css" type="text/css"></link></head><body><h2>Description: </h2><p>Executes a SQL UPDATE or INSERT command. The content of an incoming FlowFile is expected to be the SQL command to execute. The SQL command may use the ? to escape parameters. In this case, the parameters to use must exist as FlowFile attributes with the naming convention sql.args.N.type and sql.args.N.value, where N is a positive integer. The sql.args.N.type is expected to be a number indicating the JDBC Type. The content of the FlowFile is expected to be in UTF-8 format.</p><h3>Tags: </h3><p>sql, put, rdbms, database, update, insert, relational</p><h3>Properties: </h3><p>In the list below, the names of required properties appear in <strong>bold</strong>. Any other properties (not in bold) are considered optional. The table also indicates any default values.</p><table id="properties"><tr><th>Name</th><th>Default Value</th><th>Allowable Values</th><th>Description</th></tr><tr><td id="name"><strong>JDBC Connection Pool</strong></td><td id="default-value"></td><td id="allowable-values"><strong>Controller Service API: </strong><br/>DBCPService<br/><strong>Implementation:</strong><br/><a href="../org.apache.nifi.dbcp.DBCPConnectionPool/index.html">DBCPConnectionPool</a></td><td id="description">Specifies the JDBC Connection Pool to use in order to convert the JSON message to a SQL statement. The Connection Pool is necessary in order to determine the appropriate database column types.</td></tr><tr><td id="name">Support Fragmented Transactions</td><td id="default-value">true</td><td id="allowable-values"><ul><li>true</li><li>false</li></ul></td><td id="description">If true, when a FlowFile is consumed by this Processor, the Processor will first check the fragment.identifier and fragment.count attributes of that FlowFile. If the fragment.count value is greater than 1, the Processor will not process any FlowFile will that fragment.identifier until all are available; at that point, it will process all FlowFiles with that fragment.identifier as a single transaction, in the order specified by the FlowFiles' fragment.index attributes. This Provides atomicity of those SQL statements. If this value is false, these attributes will be ignored and the updates will occur independent of one another.</td></tr><tr><td id="name">Transaction Timeout</td><td id="default-value"></td><td id="allowable-values"></td><td id="description">If the &lt;Support Fragmented Transactions&gt; property is set to true, specifies how long to wait for all FlowFiles for a particular fragment.identifier attribute to arrive before just transferring all of the FlowFiles with that identifier to the 'failure' relationship</td></tr><tr><td id="name"><strong>Batch Size</strong></td><td id="default-value">100</td><td id="allowable-values"></td><td id="description">The preferred number of FlowFiles to put to the database in a single transaction</td></tr><tr><td id="name">Obtain Generated Keys</td><td id="default-value">false</td><td id="allowable-values"><ul><li>true</li><li>false</li></ul></td><td id="description">If true, any key that is automatically generated by the database will be added to the FlowFile that generated it using the sql.generate.key attribute. This may result in slightly slower performance and is not supported by all databases.</td></tr></table><h3>Relationships: </h3><table id="relationships"><tr><th>Name</th><th>Description</th></tr><tr><td>retry</td><td>A FlowFile is routed to this relationship if the database cannot be updated but attempting the operation again may succeed</td></tr><tr><td>failure</td><td>A FlowFile is routed to this relationship if the database cannot be updated and retrying the operation will also fail, such as an invalid query or an integrity constraint violation</td></tr><tr><td>success</td><td>A FlowFile is routed to this relationship after the database is successfully updated</td></tr></table><h3>Reads Attributes: </h3><table id="reads-attributes"><tr><th>Name</th><th>Description</th></tr><tr><td>fragment.identifier</td><td>If the &lt;Support Fragment Transactions&gt; property is true, this attribute is used to determine whether or not two FlowFiles belong to the same transaction.</td></tr><tr><td>fragment.count</td><td>If the &lt;Support Fragment Transactions&gt; property is true, this attribute is used to determine how many FlowFiles are needed to complete the transaction.</td></tr><tr><td>fragment.index</td><td>If the &lt;Support Fragment Transactions&gt; property is true, this attribute is used to determine the order that the FlowFiles in a transaction should be evaluated.</td></tr><tr><td>sql.args.N.type</td><td>Incoming FlowFiles are expected to be parameterized SQL statements. The type of each Parameter is specified as an integer that represents the JDBC Type of the parameter.</td></tr><tr><td>sql.args.N.value</td><td>Incoming FlowFiles are expected to be parameterized SQL statements. The value of the Parameters are specified as sql.args.1.value, sql.args.2.value, sql.args.3.value, and so on. The type of the sql.args.1.value Parameter is specified by the sql.args.1.type attribute.</td></tr></table><h3>Writes Attributes: </h3><table id="writes-attributes"><tr><th>Name</th><th>Description</th></tr><tr><td>sql.generated.key</td><td>If the database generated a key for an INSERT statement and the Obtain Generated Keys property is set to true, this attribute will be added to indicate the generated key, if possible. This feature is not supported by all database vendors.</td></tr></table><h3>See Also:</h3><p><a href="../org.apache.nifi.processors.standard.ConvertJSONToSQL/index.html">ConvertJSONToSQL</a></p></body></html>